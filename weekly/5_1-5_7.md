# Weekly Note 5/1 - 5/7

## Mini-goals this week
- [libnfd](https://github.com/izgzhen/nfd)
    - [ ] Write complete set of rust-style bindings
    - [ ] Keep testing, and solve the issues
        - https://github.com/izgzhen/nfd/issues/5
        - https://github.com/izgzhen/nfd/issues/4
- [ ] Land PR [Fixing TODOs related to file input and File API](https://github.com/servo/servo/pull/10873)
    - Update: Looks very immature. But maybe I can break it down a bit.
- [ ] Tracking the [`BlobPart` issue](https://github.com/servo/servo/issues/10911)
- [ ] Analyze the File API test suite "FAIL" cases and file more issues discussing the problem
- [x] Investigate the following issues
    + [Preliminary design](../notes/file-support-design-doc.md)

## Process isolation and Sandboxing
From Manish:

> Currently there's only one place where the script gets access to on-disk files; that is when the user selects a file to upload -- the file is accessible as an attribute on the file input. To make this secure, we need the resource thread (or other task in the trusted root process) to spawn the upload dialog; create a Rust File object, give it a UUID, store it in a map, and pass the UUID on to the script which stores it inside the DOM File object. Any time the script wishes to read the DOM File object, it requests the relevant bits from the resource task, identifying the file with the UUID.

> As mentioned in email, we need to be careful about process isolation here. The script task should never be reading files directly, nor should it be possible for the script task to ask another process to read an arbitrary file for it. Instead, the script task should ask the resource task to spawn a file dialog, and the resource task should return some handle through which the script task can refer to the file.

> One thing you may want to account for is sandboxing. In multiprocess mode, Servo's script process is sandboxed and can't access the filesystem or the network. So all the code that actually reads from the filesystem will need to be in the resource task (or somewhere else). Additionally, it should be designed such that if a script process is compromised and can run arbitrary code, it cannot read arbitrary on-disk files by asking the resource task; it should only be able to read files which it is allowed to.

